# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14Chj6dmSaoYA6HBoUGgs6h8O5QBD1U70
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import plotly.express as px

# Loading dataset
df = pd.read_csv('https://raw.githubusercontent.com/PatieCodes/Dashboards/refs/heads/main/communities.data')

print(df.head())

# Replacing '?' with NaN and then dropping missing values
df = df.replace('?', np.nan)
df.dropna(inplace=True)
print(df.head())

#Viewing entire dataset
display(df)

import requests
import io

# data dictionary
data_dictionary_path = 'https://raw.githubusercontent.com/PatieCodes/Dashboards/refs/heads/main/communities.names'

# Fetch the content of the .names file
response = requests.get(data_dictionary_path)
response.raise_for_status() # Raise an exception for HTTP errors
names_content = response.text

new_column_names = []
for line in names_content.splitlines():
    line = line.strip()
    if line.startswith('@attribute'):
        # Extract the attribute name
        parts = line.split()
        attribute_name = parts[1]
        new_column_names.append(attribute_name)

# Check if the number of new column names matches the number of columns in df
if len(new_column_names) == df.shape[1]:
    df.columns = new_column_names
    print("Columns renamed successfully!")
    print(df.head())
else:
    print(f"Error: The number of new column names ({len(new_column_names)}) does not match the number of columns in the DataFrame ({df.shape[1]}).")
    print("Please ensure your data dictionary file is correctly parsed to extract column names.")
    print("Extracted names count:", len(new_column_names))
    print("DataFrame columns count:", df.shape[1])

# Select only numeric columns for correlation calculation
numeric_df = df.select_dtypes(include=np.number)

# Calculate the correlation matrix
correlation_matrix = numeric_df.corr()

# Plotting the heatmap
plt.figure(figsize=(20, 18))
sns.heatmap(correlation_matrix, annot=False, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Matrix')
plt.show()

# Define the columns for the subset
subset_columns = ['state', 'ViolentCrimesPerPop', 'population', 'PctEmploy', 'NumImmig', 'RentMedian', 'NumInShelters']

# Create the subset DataFrame
df_subset = df[subset_columns]
print(df_subset.head())

# Calculate the correlation matrix for the subset
correlation_matrix_subset = df_subset.corr()

# Plotting the heatmap for the subset
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix_subset, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Matrix Heatmap for Selected Features')
plt.show()

#Distribution of Violent Crimes Per Population
plt.figure(figsize=(15, 5))
plt.subplot(1, 3, 1)
sns.histplot(df_subset['ViolentCrimesPerPop'], kde=True)
plt.title('Distribution of Violent Crimes Per Pop')

#Distribution of Percentage Employed
plt.subplot(1, 3, 3)
sns.histplot(df_subset['PctEmploy'], kde=True)
plt.title('Distribution of Percentage Employed')
plt.tight_layout()
plt.show()

# Create a boxplot of ViolentCrimesPerPop by state
plt.figure(figsize=(12, 6))
sns.boxplot(x='state', y='ViolentCrimesPerPop', data=df_subset, palette='Set1')
plt.title('Distribution of Violent Crimes Per Population by State', fontsize=16)
plt.xlabel('State', fontsize=12)
plt.ylabel('Violent Crimes Per Population', fontsize=12)
plt.xticks(rotation=60, ha='right', fontsize=10)
plt.yticks(fontsize=10)
plt.tight_layout()
plt.show()

#Pair plot for subset relationships
print("Generating Pair Plot for all selected features...")
sns.pairplot(df_subset, diag_kind='kde')
plt.suptitle('Pair Plot of Selected Features', y=1.02) # Adjust suptitle to prevent overlap
plt.show()

#Introducing communityname in subset
subset_columns2 = ['state', 'ViolentCrimesPerPop', 'population', 'PctEmploy', 'NumImmig', 'RentMedian', 'NumInShelters','communityname']

# Create the subset DataFrame
df_subset2 = df[subset_columns2]

# Interactive Scatterplot for high correlation with ViolentCrimesPerPop
fig = px.scatter(df_subset2,
                 x='ViolentCrimesPerPop',
                 y='NumInShelters',
                 color='communityname',
                 hover_data=['state', 'population', 'PctEmploy', 'NumImmig', 'RentMedian'],
                 title='Violent Crimes vs Number In Shelters',
                 width=900, # Set a reasonable width for the plot
                 height=600) # Set a reasonable height for the plot
fig.update_layout(title_x=0.5) # Center the title
fig.update_traces(marker=dict(size=8)) # Adjust marker size
fig.show()



df_agg_state = df_subset2.groupby('state').agg(
    ViolentCrimesPerPop_Avg=('ViolentCrimesPerPop', 'mean'),
    CommunityNames=('communityname', lambda x: ', '.join(x.unique()))
).reset_index()

df_agg_state['state'] = df_agg_state['state'].astype(str).str.zfill(2)

print(df_agg_state.head())

import requests

geoj_url = "https://raw.githubusercontent.com/PatieCodes/Dashboards/refs/heads/main/gz_2010_us_040_00_500k.json"

# Download the file
response = requests.get(geoj_url)
response.raise_for_status() # Raise an exception for HTTP errors

# Save the content to a local file named states.geojson
with open("states.geojson", "w") as f:
    f.write(response.text)

print("states.geojson has been downloaded and saved to your environment from a fourth alternative source.")

import json

with open("states.geojson") as f:
    geo = json.load(f)

df_agg_state["state"] = df_agg_state["state"].astype(str).str.zfill(2)

fig = px.choropleth(
    df_agg_state,
    geojson=geo,
    locations="state",
    featureidkey="properties.STATE",
    color="ViolentCrimesPerPop_Avg",
    hover_name="CommunityNames",
    hover_data={"ViolentCrimesPerPop_Avg": True},
    color_continuous_scale="Viridis",
    title="Average Violent Crimes Per Population by State",
    width=900,
    height=600
)

fig.update_geos(fitbounds="locations", visible=False, showcountries=True)
fig.update_layout(title_x=0.5)
fig.show()

